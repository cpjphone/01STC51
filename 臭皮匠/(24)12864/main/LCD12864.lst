C51 COMPILER V9.01   LCD12864                                                              08/26/2013 15:22:28 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE LCD12864
OBJECT MODULE PLACED IN .\LCD12864.obj
COMPILER INVOKED BY: D:\(3)keil4\C51\BIN\C51.EXE ..\LCD12864\LCD12864.c BROWSE INCDIR(..\LCD12864) DEBUG OBJECTEXTEND PR
                    -INT(.\LCD12864.lst) OBJECT(.\LCD12864.obj)

line level    source

   1          /********************************************************************************************
   2          名称：LCD12864.c
   3          功能：12864液晶显示屏并口驱动程序
   4          作者：
   5          时间：
   6          *********************************************************************************************/             
   7          #include "STC_NEW_8051.H"
*** WARNING C318 IN LINE 7 OF ..\LCD12864\LCD12864.c: can't open file 'STC_NEW_8051.H'
   8          #include "LCD12864.h"
*** WARNING C318 IN LINE 4 OF ..\LCD12864\LCD12864.H: can't open file 'Type_Define.h'
*** WARNING C318 IN LINE 5 OF ..\LCD12864\LCD12864.H: can't open file 'Font.h'
*** WARNING C318 IN LINE 6 OF ..\LCD12864\LCD12864.H: can't open file 'AlarmClock.h'
*** ERROR C202 IN LINE 11 OF ..\LCD12864\LCD12864.H: 'P3': undefined identifier
*** ERROR C202 IN LINE 12 OF ..\LCD12864\LCD12864.H: 'P3': undefined identifier
*** ERROR C202 IN LINE 13 OF ..\LCD12864\LCD12864.H: 'P3': undefined identifier
*** ERROR C202 IN LINE 14 OF ..\LCD12864\LCD12864.H: 'P0': undefined identifier
*** ERROR C202 IN LINE 15 OF ..\LCD12864\LCD12864.H: 'P2': undefined identifier
*** ERROR C141 IN LINE 19 OF ..\LCD12864\LCD12864.H: syntax error near 'cmdcode', expected ')'
*** ERROR C141 IN LINE 20 OF ..\LCD12864\LCD12864.H: syntax error near 'Dispdata', expected ')'
*** ERROR C141 IN LINE 21 OF ..\LCD12864\LCD12864.H: syntax error near '*', expected ')'
*** ERROR C141 IN LINE 27 OF ..\LCD12864\LCD12864.H: syntax error near 'x', expected ')'
*** ERROR C141 IN LINE 28 OF ..\LCD12864\LCD12864.H: syntax error near 'x', expected ')'
*** ERROR C141 IN LINE 29 OF ..\LCD12864\LCD12864.H: syntax error near 'x', expected ')'
   9          
  10          /*==========================12864液晶显示屏并口驱动程序=============================*/
  11          //===========检查忙位
  12          void chk_busy()
  13          {
  14   1         LCM_RS=0; LCM_RW=1; LCM_EN=1;
*** ERROR C202 IN LINE 14 OF ..\LCD12864\LCD12864.C: 'LCM_RS': undefined identifier
*** ERROR C202 IN LINE 14 OF ..\LCD12864\LCD12864.C: 'LCM_RW': undefined identifier
*** ERROR C202 IN LINE 14 OF ..\LCD12864\LCD12864.C: 'LCM_EN': undefined identifier
  15   1         Lcd_Bus=0xff;
*** ERROR C202 IN LINE 15 OF ..\LCD12864\LCD12864.C: 'P1': undefined identifier
  16   1         while((Lcd_Bus&0x80)==0x80);
*** ERROR C202 IN LINE 16 OF ..\LCD12864\LCD12864.C: 'P1': undefined identifier
  17   1         LCM_EN=0;
*** ERROR C202 IN LINE 17 OF ..\LCD12864\LCD12864.C: 'LCM_EN': undefined identifier
  18   1      }
  19          //================写指令到LCD=============================
  20          void write_com(uchar cmdcode)
*** ERROR C141 IN LINE 20 OF ..\LCD12864\LCD12864.C: syntax error near 'cmdcode', expected ')'
  21          {
  22   1              chk_busy();
  23   1              LCM_RS=0; LCM_RW=0; LCM_EN=1;
*** ERROR C202 IN LINE 23 OF ..\LCD12864\LCD12864.C: 'LCM_RS': undefined identifier
*** ERROR C202 IN LINE 23 OF ..\LCD12864\LCD12864.C: 'LCM_RW': undefined identifier
*** ERROR C202 IN LINE 23 OF ..\LCD12864\LCD12864.C: 'LCM_EN': undefined identifier
  24   1              Lcd_Bus=cmdcode;
*** ERROR C202 IN LINE 24 OF ..\LCD12864\LCD12864.C: 'P1': undefined identifier
  25   1              LCM_EN=0;
*** ERROR C202 IN LINE 25 OF ..\LCD12864\LCD12864.C: 'LCM_EN': undefined identifier
  26   1      }
  27          //=================写数据到LCD==============================
C51 COMPILER V9.01   LCD12864                                                              08/26/2013 15:22:28 PAGE 2   

  28          void write_data(uchar Dispdata)
*** ERROR C141 IN LINE 28 OF ..\LCD12864\LCD12864.C: syntax error near 'Dispdata', expected ')'
  29          {        
  30   1              chk_busy();      //检查忙位
  31   1              LCM_RS=1; LCM_RW=0; LCM_EN=1;
*** ERROR C202 IN LINE 31 OF ..\LCD12864\LCD12864.C: 'LCM_RS': undefined identifier
*** ERROR C202 IN LINE 31 OF ..\LCD12864\LCD12864.C: 'LCM_RW': undefined identifier
*** ERROR C202 IN LINE 31 OF ..\LCD12864\LCD12864.C: 'LCM_EN': undefined identifier
  32   1              Lcd_Bus=Dispdata;
*** ERROR C202 IN LINE 32 OF ..\LCD12864\LCD12864.C: 'P1': undefined identifier
  33   1              LCM_EN=0;
*** ERROR C202 IN LINE 33 OF ..\LCD12864\LCD12864.C: 'LCM_EN': undefined identifier
  34   1      }
  35          //==========向LCM发送一个字符串,长度64字符之内============
  36          void lcm_w_word(uchar *s)
*** ERROR C141 IN LINE 36 OF ..\LCD12864\LCD12864.C: syntax error near '*', expected ')'
  37          {
  38   1              while(*s>0) { write_data(*s); s++; }  //应用：lcm_w_word("您好！");
*** ERROR C202 IN LINE 38 OF ..\LCD12864\LCD12864.C: 's': undefined identifier
*** ERROR C202 IN LINE 38 OF ..\LCD12864\LCD12864.C: 's': undefined identifier
*** ERROR C202 IN LINE 38 OF ..\LCD12864\LCD12864.C: 's': undefined identifier
  39   1      }
  40          /******************************************************************************/
  41          void lcm_w_test(bit i,unsigned char word){//写指令或数据（被调用层）
  42   1              if(i == 0){
  43   2                      write_com(word);//写指令（0，指令）
  44   2              }else{
  45   2                      write_data(word);//写数据（1，数据）
  46   2              }
  47   1      }
  48          //===========清屏函数=====================================
  49          void lcm_clr(void)
  50          {
  51   1              write_com(0x30);        
  52   1              write_com(0x01);
  53   1              delayms(5);     
  54   1      }
  55          
  56          //=========================================================
  57          
  58          void lcm_clr2(void){//清屏上面3行（用空格填满要清显示的地方，因为液晶屏是静态显示的，所以这办法常用）
  59   1              lcm_w_test(0,0x80);//第一行
  60   1              lcm_w_word("                ");
  61   1                  //标尺("1234567812345678"应该能够显示满一行)
  62   1              lcm_w_test(0,0x90);//第二行
  63   1              lcm_w_word("                ");
  64   1                  //标尺("1234567812345678"应该能够显示满一行)
  65   1              lcm_w_test(0,0x88);//第一行
  66   1              lcm_w_word("                ");
  67   1                  //标尺("1234567812345678"应该能够显示满一行)
  68   1      }
  69          //========================================================================
  70           void lcm_clr3(void){//清屏中间2行（用空格填满要清显示的地方，因为液晶屏是静态显示的，所以这办法常用）
  71   1              lcm_w_test(0,0x90);//第二行
  72   1              lcm_w_word("                ");
  73   1                  //标尺("1234567812345678"应该能够显示满一行)
  74   1              lcm_w_test(0,0x88);//第一行
  75   1              lcm_w_word("                ");
  76   1                  //标尺("1234567812345678"应该能够显示满一行)
  77   1              lcm_w_test(0,0x9f);//第一行
  78   1              lcm_w_word("  ");
  79   1                  //标尺("1234567812345678"应该能够显示满一行)
C51 COMPILER V9.01   LCD12864                                                              08/26/2013 15:22:28 PAGE 3   

  80   1      }
  81          //==================初始化LCD屏===============================
  82          void lcm_init()
  83          {       
  84   1              
  85   1              write_com(0x30);  //选择8bit数据流
  86   1              write_com(0x0c);  //开显示(无游标、不反白)
  87   1              lcm_clr();        //清除显示，并且设定地址指针为00H
  88   1              write_com(0x06);  //光标右移,DDRAM位址计数器(AC)加1,不整屏移动
  89   1              lcm_clr2();
  90   1              
  91   1      }
  92          /*-------------------使用绘图的方法让一个16*16的汉字符反白---------------------------
  93                  形式参数:uchar x,uchar y,uchar wide,uchar bkcor
  94                  行参说明:坐标水平位置,坐标垂直位置,反白行数,要反白还是清除(1:反白,0:清除)
  95          -----------------------------------------------------------------------------------*/
  96          void write1616GDRAM(uchar x,uchar y,uchar sign,uchar *bmp)      
  97          { 
  98   1              uchar i,j,basex;
  99   1              write_com(0x36);      //扩展指令，绘图模式命令，开显示也可以绘.(关图片显示0x34)
 100   1              if(y==1||y==2)    //第一第二行
 101   1              {
 102   2                      basex=0x80;        //上半屏
 103   2                      y=(y-1)*16;       //垂直位址从0X80开始.
 104   2              }
 105   1              if(y==3||y==4)  //第三第四行
 106   1              {
 107   2                      basex=0x88;      //下半屏
 108   2                      y=(y-3)*16;      //垂直位址都是从0X80开始的，不管上下半屏。
 109   2              }
 110   1              for(i=0;i<16;i++)       //
 111   1              {                                                                                                                       
 112   2                      write_com(0x80+y+i);  //写入垂直位址。
 113   2                      write_com(basex+x-1); //再写入水平位址(上半屏第一字为0X80，……第七字为0X87)
 114   2                                                                 //下半屏第一字为0X88，……第七字为0X8F；
 115   2                      for(j=0;j<2;j++)   //再写入两个8位元的数据,AC会自动增一，接着写数据
 116   2                      {
 117   3                              if(sign==1)  
 118   3                                      write_data(~(*bmp++));
 119   3                              else  
 120   3                                      write_data(*bmp++);
 121   3                      }
 122   2              }       
 123   1              write_com(0x36);  //写完数据，开图片显示     
 124   1      }
 125          
 126          /*=====================================================================================
 127                  函数功能:显示16X16图形,适用于st7920型液晶
 128                  形式参数:uchar x,uchar y,uchar *bmp
 129                  行参说明:横坐标X列，纵坐标Y行，sign=1反白、=0不反，tt是要显示的图形bmp1616中的第几个
 130          ======================================================================================*/ 
 131          void set1616pic(uchar x,uchar y,uchar sign,uchar tt) 
 132          {
 133   1              uchar (*pp)[32];         //定义指针
 134   1              pp=bmp1616;       //二维数组首地址给指针，故指针指向下一个数组地址应为加64
 135   1              write1616GDRAM(x,y,sign,pp[tt]); //写入小时的十位         
 136   1      }
 137          /*=====================================================================================
 138                  函数功能:显示16X32图形,适用于st7920型液晶
 139                  形式参数:uchar x,uchar y,uchar *bmp
 140                  行参说明:横坐标X列，纵坐标Y行，要显示的图形BMP
 141          =====================================================================================*/           
C51 COMPILER V9.01   LCD12864                                                              08/26/2013 15:22:28 PAGE 4   

 142          void write1632GDRAM(uchar x,uchar y,uchar *bmp) 
 143          { 
 144   1              uchar i,j,basex,basey;
 145   1              switch(y)        //由y纵坐标定是上半屏还是下半屏
 146   1              {
 147   2                case 1: basex=0x80; break;  //上半屏
 148   2                case 2: basex=0x80; break;  //先上半屏，下面再下半屏。
 149   2                case 3: basex=0x88; break;  //下半屏
 150   2                default:   return;   //别的则返回
 151   2              }
 152   1              basey=basex+x-1;
 153   1              write_com(0x36);  
 154   1              if(y==1||y==3)  //如为第一第三行，则直接是在同一半屏，直接绘完32行点陈数据。
 155   1              {
 156   2                        for(i=0;i<32;i++)      //写入32行点阵
 157   2                        {                                                                                                             
 158   3                                  write_com(0x80+i);  //先写入垂直位址,选上下32行的哪一行,
 159   3                                                                              //不管上下半屏，首行都为0X80
 160   3                                  write_com(basey);   //再写入水平位址(选上下半屏)
 161   3                                  for(j=0;j<2;j++)           //2个8位元的数据,即16BIT宽度
 162   3                                      write_data(*bmp++);   
 163   3                        }      
 164   2              }
 165   1              if(y==2)  //从第二行开始则画图将上下半屏都有，所以先画完上半屏16行，再画下半屏16行。
 166   1              {                                       
 167   2                        for(i=0;i<16;i++)      //写入上半屏16行点阵
 168   2                        {                                                                                                             
 169   3                                  write_com(0x90+i);  //先写入垂直位址,选上下32行的哪一行,不管上下半屏，
 170   3                                                                              //首行都为0X80，第二行为0X90。
 171   3                                  write_com(basey);   //(选上半屏)再写入水平位址
 172   3                                  for(j=0;j<2;j++)           //2个8位元的数据,即16BIT宽度
 173   3                                      write_data(*bmp++);   
 174   3                        }
 175   2                        for(i=0;i<16;i++)      //写入下半屏16行点阵
 176   2                        {                                                                                                             
 177   3                                  write_com(0x80+i);  //先写入垂直位址,选上下32行的哪一行,不管上下半屏，首行都为0X80
 178   3                                  write_com(basey+8);   //(选下半屏)再写入水平位址
 179   3                                  for(j=0;j<2;j++)           //2个8位元的数据,即16BIT宽度
 180   3                                      write_data(*bmp++);   
 181   3                        }      
 182   2              }
 183   1              write_com(0x36);  //写完数据，开图片显示     
 184   1      }
 185          /*=====================================================================================        
 186                  函数名称: init_12864_GDRAM()
 187                  功能描述: 在程写GDRAM时序初始化12864 
 188          =====================================================================================*/
 189          void init_12864_GDRAM()  
 190          {
 191   1         
 192   1              write_com(0x30);     //基本指令操作(扩充指令操作为:0x34)
 193   1              write_com(0x0C);     //整体显示ON，游标OFF，游标位置OFF
 194   1              write_com(0x06);         //光标右移,DDRAM位址计数器(AC)加1,不整屏移动
 195   1              lcm_clr();           //清屏 (清DDRAM)
 196   1      }
 197          
 198          /*======================================================================================
 199                  函数名称:Clean_12864_GDRAM(void)                                                
 200                  函数功能:清屏函数
 201                  使用说明:GDRAM填满0
 202          =======================================================================================*/
 203          void Clean_12864_GDRAM(void)
C51 COMPILER V9.01   LCD12864                                                              08/26/2013 15:22:28 PAGE 5   

 204          {
 205   1          uchar x,y;
 206   1          write_com(0x36);
 207   1          init_12864_GDRAM();         //设置扩展指令集，按手册说明，仅设置了绘图位，
 208   1          write_com(0x36);    //需要两次，本次设置扩展指令集。
 209   1          for (y=0;y<32;y++)
 210   1          {
 211   2              write_com(0x80+y);  //设置y=1000+00xx，y+1则往下一行
 212   2              write_com(0x80);        //设置x=1000 0000
 213   2              for (x=0;x<16;x++)
 214   2              {
 215   3                  write_data(0x00);   //高字节数据
 216   3                  write_data(0x00);   //低字节数据
 217   3              }
 218   2          }
 219   1      }
 220          /*------------------显示图片------------------------*/ 
 221          /*
 222          void Disp_Img(unsigned char code *img) 
 223          {  unsigned int j=0; 
 224             unsigned char x,y,i; 
 225                 for(i=0;i<9;i+=8) 
 226                 for(y=0;y<32;y++)//原来 为 y<26 ,上下两个半屏不能正常对接显示，导致显示的图片中间有空隙           
 227                   for(x=0;x<8;x++) 
 228                   {  write_com(0x36);//功能设置---8BIT控制界面，扩充指令集        
 229                      write_com(y+0x80);        //行地址 
 230                      write_com(x+0x80+i);     //列地址 
 231                      write_com(0x30); 
 232                      write_data(img[j++]); //写数据还要回到基本指令集     
 233                      write_data(img[j++]); 
 234                   }   
 235                     
 236          } 
 237          */
 238          
 239          /**************************************************************************/
 240          //-------------------------------------------
 241          //函数功能:显示128x64图形,适用于st7920型液晶
 242          //-------------------------------------------
 243          /************************************************************************           
 244           */
 245          void write12864GDRAM(unsigned char code *img)
 246          {
 247   1       uchar i,j;
 248   1         for(j=0;j<32;j++)                    //绘制上半屏
 249   1         {
 250   2           for(i=0;i<8;i++)
 251   2           {
 252   3             write_com(0x34);         //0011 0100 扩充功能设定――8位数据 扩充指令操作 绘图开
 253   3             write_com(0x80+j);               //1xxx xxxx 设定绘图RAM――先设定垂直(列)地址AC6 AC5…AC0
 254   3             write_com(0x80+i);               //1000 0xxx 设定绘图RAM――再设定水平(行)地址AC3AC2AC1AC0
 255   3             write_com(0x30);         //0011 0000 扩充功能设定――8位数据 基本指令操作
 256   3             write_data(img[j*16+i*2]);
 257   3             write_data(img[j*16+i*2+1]);
 258   3           }
 259   2         }
 260   1         for(j=32;j<64;j++)                   //绘制下半屏
 261   1         {
 262   2           for(i=0;i<8;i++)
 263   2           {
 264   3             write_com(0x34);         //0011 0100 扩充功能设定――8位数据 扩充指令操作 绘图开
 265   3             write_com(0x80+j-32);            //1xxx xxxx 设定绘图RAM――先设定垂直(列)地址AC6 AC5…AC0
C51 COMPILER V9.01   LCD12864                                                              08/26/2013 15:22:28 PAGE 6   

 266   3             write_com(0x88+i);               //1000 1xxx 设定绘图RAM――再设定水平(行)地址AC3AC2AC1AC0
 267   3             write_com(0x30);         //0011 0000 扩充功能设定――8位数据 基本指令操作
 268   3             write_data(img[j*16+i*2]);
 269   3             write_data(img[j*16+i*2+1]);
 270   3           }
 271   2         }
 272   1         write_com(0x36);
 273   1      }
 274          /*=======================================================================================*/ 

C51 COMPILATION COMPLETE.  4 WARNING(S),  33 ERROR(S)
